type hchan struct {
	qcount   uint           // total data in the queue
	dataqsiz uint           // size of the circular queue
	buf      unsafe.Pointer // points to an array of dataqsiz elements
	elemsize uint16
	closed   uint32
	elemtype *_type // element type
	sendx    uint   // send index
	recvx    uint   // receive index
	recvq    waitq  // list of recv waiters
	sendq    waitq  // list of send waiters

	// lock protects all fields in hchan, as well as several
	// fields in sudogs blocked on this channel.
	//
	// Do not change another G's status while holding this lock
	// (in particular, do not ready a G), as this can deadlock
	// with stack shrinking.
	lock mutex
}

func makechan(t *chantype, size int) *hchan {
	elem := t.elem
	if elem.size >= 1<<16 { 	// compiler checks this but be safe.
		throw("makechan: invalid channel element type")
	}
    ...
	var c *hchan
	switch {
	case size == 0 || elem.size == 0:   // Queue or element size is zero.
		c = (*hchan)(mallocgc(hchanSize, nil, true))
		// Race detector uses this location for synchronization.
		c.buf = unsafe.Pointer(c)
	case elem.kind&kindNoPointers != 0: // Elements do not contain pointers.
		// Allocate hchan and buf in one call.
		c = (*hchan)(mallocgc(hchanSize+uintptr(size)*elem.size, nil, true))
		c.buf = add(unsafe.Pointer(c), hchanSize)
	default:                            // Elements contain pointers.
		c = new(hchan)
		c.buf = mallocgc(uintptr(size)*elem.size, elem, true)
	}
    ...
	return c
}

func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {
// SEND_NIL OMIT
    if c == nil {
		if !block {
			return false
		}
		gopark(nil, nil, "chan send (nil chan)", traceEvGoStop, 2)
		throw("unreachable")
	}
// SEND_NIL OMIT

// SEND_FAST OMIT
	if !block && c.closed == 0 && ((c.dataqsiz == 0 && c.recvq.first == nil) ||
		(c.dataqsiz > 0 && c.qcount == c.dataqsiz)) {
		return false
	}
// SEND_FAST OMIT

	var t0 int64
	if blockprofilerate > 0 {
		t0 = cputicks()
	}

// SEND_LOCK_DIRECT OMIT
	lock(&c.lock)
	if c.closed != 0 {
		unlock(&c.lock)
		panic(plainError("send on closed channel"))
	}
	if sg := c.recvq.dequeue(); sg != nil {
		// Found a waiting receiver. We pass the value we want to send
		// directly to the receiver, bypassing the channel buffer (if any).
		send(c, sg, ep, func() { unlock(&c.lock) }, 3)
		return true
	}
// SEND_LOCK_DIRECT OMIT

// SEND_LOCK_BUF OMIT
	lock(&c.lock)
    ...
	if c.qcount < c.dataqsiz {
		// Space is available in the channel buffer. Enqueue the element to send.
		qp := chanbuf(c, c.sendx)          
		typedmemmove(c.elemtype, qp, ep)   
		c.sendx++
		if c.sendx == c.dataqsiz {         
			c.sendx = 0
		}
		c.qcount++
		unlock(&c.lock)
		return true
	}
// SEND_LOCK_BUF OMIT

// SEND_BLOCK OMIT
	lock(&c.lock)
    ...
	if !block {
		unlock(&c.lock)
		return false
	}
	// Block on the channel. Some receiver will complete our operation for us.
	gp := getg()
	mysg := acquireSudog()
	mysg.elem = ep      // this will be used by receiver later
	...
	c.sendq.enqueue(mysg)
	goparkunlock(&c.lock, "chan send", traceEvGoBlockSend, 3)
// SEND_BLOCK OMIT

// SEND_FINISHED OMIT
	...
	if gp.param == nil { // this param must be filled by a receiver
		if c.closed == 0 {
			throw("chansend: spurious wakeup")
		}
		panic(plainError("send on closed channel"))
	}
	releaseSudog(mysg)
	return true
}
// SEND_FINISHED OMIT

