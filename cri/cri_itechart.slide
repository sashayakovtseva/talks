Extending Kubernetes
Implementing Singularity-CRI
16 May 2019

Sasha Yakovtseva
Go Developer

a.yakautsava@itechart-group.com
sashayakovtseva@gmail.com
sasha@sylabs.io

* Agenda

- Kubernetes
- CRI
- Singularity
- Implementation details
- Q/A session

* What is K8s?

_Kubernetes_ is:

- an open-source platform for managing containerized apps
- large and rapidly growing ecosystem
- a tool traditionally used to manage container services at scale

* K8s Clusters

.image cluster.png 500 _

* K8s Nodes

.image node.png 500 _

* Why CRI?

Docker is the most widely known container runtime, the first one.

Kubelet source code works with Docker directly.

Container runtime space is rapidly evolving.

*Problem*: no possibility to integrate another container runtime
without changing kubelet source code.

* What is CRI?

CRI stands for _Container_ _Runtime_ _Interface_.

.image cri.png

Introduced in k8s v1.5 (alpha).

K8s v1.7 removed non-CRI Docker code completely (30 Jun 2017).

* What exactly is CRI?

CRI is a set of two gRPC services:

- ImageService

- RuntimeService

gRPC Service is a set of calls(methods) with defined incoming and returned messages(structs).

CRI services are defined in `api.proto` file.

That file is then used to generate `.go` file based on it.

Generated `.go` file has *<name>ServiceClient* and *<name>ServiceServer* for each service in `api.proto`.

* Known implementations

- cri-containerd
- cri-o
- rktlet
- frakti
- _singularity-cri_

* Singularity

- open source container runtime, with mobile and repeatable package format
- no root escalation in containers
- no root owned daemon to be installed on the system

.image singularity-logo.png

* Who uses Singularity?

.image singularity-users.png 500 1000

* Singularity image format

.image sif.png

* Implementing CRI

So far we know the following:

- we need to work with generated `.go` file
- that file consists of interfaces and structs

To *implement* *CRI* we need to provide two types that satisfy ImageServiceServer
and RuntimeServiceServer interfaces respectively.

Combining implementation into a single type is also possible.

Singularity CRI has two distinct types for each service server.

* Singularity-CRI in details

* ImageServiceServer interface

.code api.pb.go.txt /^type ImageServiceServer/,/^}/

* ImageServiceServer implementation details

- capable of pulling images from library/docker
- store as SIF, verify when pulling from library
- `registry.json` file is kept to restore state upon restarts
- in-memory trie is used to allow convenient search
- handles search by tags, digests
- handles image merging and update in special cases

* RuntimeServiceServer interface

- prepare OCI bundles
- prepare pod namespaces
- keep pods and containers index
- maintain the latest state of objects
- serve streaming endpoints to interact with containers

* Pod management

CRUD operations on pods.

.code api.pb.go.txt /START POD MANAGEMENT/,/END POD MANAGEMENT/

* Pod explained

- pod is a dummy process kept by the OCI engine
- it holds IPC/NET/PID/UTS namespaces that containers will join later
- responsible for configuring NET namespace using CNI plugins
- a container for containers
- when pod is stopped/removed - inner containers are too
- pod rootfs consists of `/proc` and `/dev` only
- has two states: ready, not ready

* Container management

CRUD operations on containers.

.code api.pb.go.txt /START CONTAINER MANAGEMENT/,/END CONTAINER MANAGEMENT/

* Container explained

- container is user-defined  process in prepared environment
- run in pod's context (shared pod network is the most common case)
- rootfs is overlay fs based on SIF
- logs are collected by the runtime
- has four states: created, running, exited, unknown

* Container related methods

Includes advances methods.

.code api.pb.go.txt /START CONTAINER ADVANCED/,/END CONTAINER ADVANCED/

* Streaming endpoints

Kubernetes provides features (*exec/attach/port-forward*) for users to interact with a pod and the containers in it.

Using tools on the node (e.g., nsenter) is not a portable solution.

CRI explicitly defines these calls in the API to allow runtime-specific implementations.

Singularity CRI starts a separate _streaming_ _server_ upon start.

It returns the location of the streaming server to kubelet.

Kubelet returns this information to the Kubernetes API server, which opens a streaming connection directly to the streaming server and connects it to the client.

* Singularity CRI Streaming

.code api.pb.go.txt /StreamingRuntime/,/^}/

- runtime opens _attach_ and _control_ sockets to connect to
- attach socket is used for io streams propagation
- control socket is used to send terminal resize events and ask for log rotation

* Runtime methods

Simply query runtime version and status.

.code api.pb.go.txt /START RUNTIME/,/END RUNTIME/

* Useful links

.link https://github.com/sylabs/singularity Singularity
.link https://github.com/sylabs/singularity-cri Singularity-CRI
.link https://www.sylabs.io/2018/11/towards-native-integration-between-singularity-containers-and-kubernetes-announcing-an-open-source-project/ Singularity-CRI announcement
.link https://www.sylabs.io/2019/04/the-singularity-kubernetes-integration-from-a-deep-learning-use-case-to-the-technical-specifics/ Beta release announcement
.link https://kubernetes.io/docs/concepts/ Kubernetes concepts
.link https://kubernetes.io/blog/2016/12/container-runtime-interface-cri-in-kubernetes/ Introducing Container Runtime Interface (CRI) in Kubernetes
.link https://kubernetes.io/blog/2018/05/24/kubernetes-containerd-integration-goes-ga/ Kubernetes Containerd Integration Goes GA
